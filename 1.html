<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Envirocar Movement data</title>
  <link rel="stylesheet" href="default.css">
  <link rel="stylesheet" href="lib/leaflet/leaflet.css">
  <link rel="stylesheet" href="dist/control.playback.css">
  <script src='//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js'></script>
  <script src="lib/leaflet/leaflet.js"></script>
  <script src="dist/control.trackplayback.js"></script>
  <script src="dist/leaflet.trackplayback.js"></script>
</head>

<body>
  <div id='mapid'
    style=" position: absolute; left: 0; top: 0; right: 0; bottom: 0; width: 100%; height: 100%; overflow: hidden;">
  </div>
  <div class="network">
    <h2>Network Information</h2>
    <div id="network-info">
      <main>
        <!-- <label>
          <span>Search:</span>
          <input placeholder="Enter search term" type="search" id="searchInput">
        </label> -->
        <div class="table-wrapper">
          <table id="filterTable">
            <thead>
              <tr>
                <th data-type="text">Track ID</th>
                <th data-type="text">Start Time</th>
                <th data-type="text">End Time</th>
              </tr>
            </thead>
            <tbody id="network-infos">

            </tbody>
          </table>
        </div>
      </main>
    </div>
  </div>
  <script>
    /*
      Todo: while running the visualization:
        1. identify the running track and plot in second map as the network node
        2. check if there is connection in space in time with others 
        3. if yes plot the edge between teh nodes
    */
    datageojson = []
    $.ajax({
      dataType: "json",
      url: "./data/output1.geojson",
      success: function (data1) {
        prevId = ''

        $(data1.features).each(function (key, data2) {
          id = data2.properties['track.id'];
          lat = data2.geometry.coordinates[1]
          lng = data2.geometry.coordinates[0]
          time = Date.parse(data2.properties['time']) / 1000
          if (prevId == '') {
            array1 = [];
            array1 = [{
              "lng": lng,
              "lat": lat,
              "time": time,
              "id": id
            }]
            prevId = id
          } else {
            if (prevId == id) {
              array1.push({
                "lng": lng,
                "lat": lat,
                "time": time,
                "id": id
              })
            } else {
              datageojson.push(array1)
              array1 = [];
              array1 = [{
                "lng": lng,
                "lat": lat,
                "time": time,
                "id": id

              }]
              prevId = id
            }
          }
        });

        const map = L.map('mapid').setView([51.18, 6.4], 12);
        var Stadia_AlidadeSmoothDark = L.tileLayer(
          'https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png', {
            maxZoom: 20,
            attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a>, &copy; <a href="https://openmaptiles.org/">OpenMapTiles</a> &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors'
          });
        Stadia_AlidadeSmoothDark.addTo(map)
        /*
          changing the basemap to osm
        */
        // L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        //   attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        // }).addTo(map);
        getTimeStrFromUnix = function (t, e = "s") {
          t = parseInt(1e3 * t);
          let i, n = new Date(t),
            a = n.getFullYear(),
            o = n.getMonth() + 1 < 10 ? "0" + (n.getMonth() + 1) : n.getMonth() + 1,
            r = n.getDate() < 10 ? "0" + n.getDate() : n.getDate(),
            s = n.getHours() < 10 ? "0" + n.getHours() : n.getHours(),
            c = n.getMinutes() < 10 ? "0" + n.getMinutes() : n.getMinutes(),
            l = n.getSeconds() < 10 ? "0" + n.getSeconds() : n.getSeconds();
          return i = "d" === e ? a + "-" + o + "-" + r : "h" === e ? a + "-" + o + "-" + r + " " + s : "m" ===
            e ? a + "-" + o + "-" + r + " " + s + ":" + c : a + "-" + o + "-" + r + " " + s + ":" + c + ":" +
            l
        }
        const trackplayback = L.trackplayback(datageojson, map, {
          targetOptions: {
            useImg: true,
            imgUrl: './ship.png'
          }
        });
        const trackplaybackControl = L.trackplaybackcontrol(trackplayback);
        trackplaybackControl.addTo(map);
        prev_track_id = '';
        trackplayback.on('tick', e => {
          // $('.network-ids').html(``);
          var bufferTracks = trackplayback.clock._trackController._draw._bufferTracks[0];
          // this json array holds all the points travelled uptill now with lat-longs, and if this is an interpolation then the interpolated point at the end.
          var latestPoint = bufferTracks[bufferTracks.length - 1];
          // console.log(latestPoint);
          if (!latestPoint['isOrigin'] && bufferTracks.length > 1) {
            // if the last element in the array is an interpolated point, then take the second-last element which will hold the last reported GPS location.
            latestPoint = bufferTracks[bufferTracks.length - 2];
          }
          track_id = latestPoint['id'];

          if (prev_track_id == '') {
            time_array = [];
            time_array.push(getTimeStrFromUnix(latestPoint['time']));
            prev_track_id = track_id;
          } else {
            if (track_id == prev_track_id) {
              time_array.push(getTimeStrFromUnix(latestPoint['time']));
            } else {
              $('.network #network-infos').append(
                `<tr><td>${track_id.slice(18,23)}</td>
                <td>${time_array[0]}</td>
                <td>${time_array[time_array.length-1]}</td></tr>`
              );
              1
              time_array = [];
              prev_track_id = track_id;
            }
          }
          //map.setView(latestPoint); // for making the map follow the track. But danger : this is preventing rendering of the boat icon for some reason. Uncomment only if you're ok with losing that icon.
          // table search
          // const searchInput = document.getElementById('searchInput')
          // const table = document.getElementById('filterTable')
          // const trArray = Array.prototype.slice.call(table.querySelectorAll('tbody tr'))

          // const filterTable = event => {
          //   const searchTerm = event.target.value.toLowerCase()
          //   trArray.forEach(row => {
          //     row.classList.add('hidden')
          //     const tdArray = Array.prototype.slice.call(row.getElementsByTagName('td'))
          //     tdArray.forEach(cell => {
          //       if (cell.innerText.toLowerCase().indexOf(searchTerm) > -1) {
          //         row.classList.remove('hidden')
          //       }
          //     })
          //   })
          // }

          // searchInput.addEventListener('keyup', filterTable, false)
        }, this);
      }

    }).error(function () {});
  </script>
</body>

</html>